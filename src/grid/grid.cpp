#include "grid.h"
#include "../util/types.h"
#include "../game.h"
#include <optional>
#include <vector>
#include <cmath>
#include <algorithm>
#include <climits>

using namespace std;

map<int, int> Grid::blockIdToCount;
map<int, int> Grid::blockIdToCreatedAtLvl;

/**
 * Initializes the grid to the specified cell dimensions
 * 
 * @param height the number of rows in the grid
 * @param width the number of columns in the grid 
 */
Grid::Grid(int height, int width) {
  height_ = height;
  width_ = width;

  initializeGrid();
}

/**
 * Further initializes the grid by setting all of its cells
 * to empty blocks.
 */
void Grid::initializeGrid() {
  // initialize the grid with empty blocks
  grid_.clear();
  for (int row = 0; row < height_; row++) {
    vector<GridItem> curRow;
    curRow.reserve(width_);
    for (int col = 0; col < width_; col++) {
      curRow.push_back(GridItem{nullopt});
    }
    grid_.push_back(curRow);
  }
}

/**
 * @returns the number of rows
 */
int Grid::height() const { return height_; }

/**
 * @returns the number of columns
 */
int Grid::width() const { return width_; }

/**
 * @returns the entire grid
 */
GridShape &Grid::grid() { return grid_; }

/**
 * Restarts the grid by clearing the current and next block.
 * Resets blockIDs and level information.
 */
void Grid::restart() {
  initializeGrid();
  fallingBlock_ = nullopt;
  nextBlock_ = nullopt;

  blockIdToCount.clear();
  blockIdToCreatedAtLvl.clear();
}

/**
 * @returns the current falling block
 */
std::optional<Block> &Grid::fallingBlock() {
  return fallingBlock_;
}

/**
 * @returns the next block
 */
std::optional<Block> &Grid::nextBlock() {
  return nextBlock_;
}

/**
 * @returns the hint block
 */
std::optional<Block> &Grid::hintBlock() {
  return hintBlock_;
}

/**
 * Sets the current and next block.
 * @param b the most recently generated block
 */
void Grid::setNextBlocks(const optional<Block> &b) {
  fallingBlock_ = nextBlock_;
  nextBlock_ = b;
}

/**
 * Clears lines that are completely full.
 *
 * @returns the number points generated by clearing the line
 */
int Grid::clearLines() {
  int scoredPoints = 0;
  int linesCleared = 0;

  for (int row = 0; row < grid_.size(); row++) {
    auto &gridRow = grid_.at(row);
    bool isFilled = std::all_of(gridRow.begin(), gridRow.end(), [](GridItem item) { return !!item.val; });


    if (isFilled) {
      for (auto &block : gridRow) {
        if (block.blockId) {
          blockIdToCount[*block.blockId]--;
          if (blockIdToCount[*block.blockId] == 0) {
            // bonus points
            scoredPoints += (int) pow(blockIdToCreatedAtLvl[*block.blockId] + 1, 2);

            blockIdToCount.erase(blockIdToCount.find(*block.blockId));
            blockIdToCreatedAtLvl.erase(blockIdToCreatedAtLvl.find(*block.blockId));
          }
        }
      }
      linesCleared++;
      grid_.erase(grid_.begin() + row);
    }
  }

  // for each of the lines, remove from bottom and add a new row to top
  for (int i = 0; i < linesCleared; i++) {
    vector<GridItem> blankRow(width_, GridItem{nullopt});
    grid_.insert(grid_.begin(), blankRow);
  }

  // calculate score based on scored points
  if (linesCleared == 0) {
    return 0;
  }

  // might screw up hint so recalculate it
  if (hintBlock_) {
    setHintBlock();
  }

  return (int) pow(Game::curLevelIdx_ + linesCleared, 2) + scoredPoints;
}

/**
 * Checks if the game is lost.
 *
 * @returns true if the game is over and false if not.
 */
bool Grid::isGameOver() const {
  if (fallingBlock_) {
    Block b = *fallingBlock_;
    for (int r = 0; r < b.height(); r++) {
      for (int c = 0; c < b.width(); c++) {
        int gridRow = b.bottomLeft().y - (b.height() - 1) + r;
        int gridCol = b.bottomLeft().x + c;

        if (b.shape()[r][c].val) {
          if (grid_[gridRow][gridCol].val) {
            return true;
          }
        }
      }
    }
  }
  return false;
}

/**
 * Computes the "score" of the grid for hint-finding purposes.
 * from https://codemyroad.wordpress.com/2013/04/14/tetris-ai-the-near-perfect-player/
 *
 * @returns the calculated score
 */
double Grid::gridScore() const {
  double heightWeight = -0.510066;
  double linesWeight = 0.760666;
  double holesWeight = -0.35663;
  double bumpinessWeight = -0.184483;

  return heightWeight * aggregateHeight() + linesWeight * completeLines() + holesWeight * numHoles() +
         bumpinessWeight * bumpiness();
}

/**
 * Returns the filled height of a given column
 *
 * @param col the column number
 * @returns the filled height
 */
int Grid::colHeight(int col) const {
  int row = 0;
  for (; row < height_ && !grid_[row][col].val; row++);
  return height_ - row;
}

/**
 * @returns the sum of the heights of all columns
 */
int Grid::aggregateHeight() const {
  int total = 0;
  for (int c = 0; c < width_; c++) {
    total += colHeight(c);
  }
  return total;
}

/**
 * @returns the number of rows that are completely filled
 */
int Grid::completeLines() const {
  int total = 0;
  for (auto &row : grid_) {
    bool isFilled = std::all_of(row.begin(), row.end(), [](GridItem item) { return !!item.val; });
    if (isFilled) {
      total++;
    }
  }
  return total;
}

/**
 * @returns the "bumpiness" of the grid for hint finding purposes
 */
int Grid::bumpiness() const {
  int total = 0;
  for (int c = 0; c < width_ - 1; c++) {
    total += abs(colHeight(c) - colHeight(c + 1));
  }
  return total;
}

/**
 * @returns the number of holes in the grid
 */
int Grid::numHoles() const {
  int holes = 0;
  for (int col = 0; col < width_; col++) {
    bool foundBlock = false;
    for (int row = 0; row < height_; row++) {
      if (grid_[row][col].val) {
        foundBlock = true;
      } else if (foundBlock) {
        holes++;
      }
    }
  }
  return holes;
}

/**
 * Sets the hint block.
 */
void Grid::setHintBlock() {
  if (!fallingBlock_) {
    return;
  }

  Block origHint = Block{fallingBlock_->type(), false};
  Block curHint = origHint;
  pair<double, Block> bestHint = make_pair(INT_MIN, origHint); // deep copy
  GridShape original = grid_; // deep copy

  // go through all positions and rotations
  for (int x = 0; x < width_; x++) {
    for (int i = 0; i < 4; i++) {
      curHint = origHint;
      // move to x position
      for (int _ = 0; _ < x; _++) {
        curHint.move(RIGHT, grid_);
      }

      // rotate to orientation
      for (int _ = 0; _ < i; _++) {
        curHint.rotate(CW, grid_);
      }

      curHint.drop(grid_);

      // lower score is better
      double score = gridScore();
      if (score > bestHint.first) {
        bestHint.first = score;
        bestHint.second = curHint;
      }

      grid_ = original;
    }
  }

  hintBlock_ = bestHint.second;
}
